{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { isNullish, keccak256 } from 'web3-utils';\nimport { AbiError } from 'web3-errors';\nimport { encodeParameters } from './coders/encode.js';\nconst TYPE_REGEX = /^\\w+/;\nconst ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nconst getDependencies = function (typedData, type) {\n  let dependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const match = type.match(TYPE_REGEX);\n  const actualType = match[0];\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n  return [actualType, ...typedData.types[actualType].reduce((previous, _type) => [...previous, ...getDependencies(typedData, _type.type, previous).filter(dependency => !previous.includes(dependency))], [])];\n};\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nconst encodeType = (typedData, type) => {\n  const [primary, ...dependencies] = getDependencies(typedData, type);\n  // eslint-disable-next-line @typescript-eslint/require-array-sort-compare\n  const types = [primary, ...dependencies.sort()];\n  return types.map(dependency => // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  \"\".concat(dependency, \"(\").concat(typedData.types[dependency].map(_type => \"\".concat(_type.type, \" \").concat(_type.name)), \")\")).join('');\n};\n/**\n * Get a type string as hash.\n */\nconst getTypeHash = (typedData, type) => keccak256(encodeType(typedData, type));\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nconst getStructHash = (typedData, type, data) => keccak256(encodeData(typedData, type, data));\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nexport const getMessage = (typedData, hash) => {\n  const EIP_191_PREFIX = '1901';\n  const message = \"0x\".concat(EIP_191_PREFIX).concat(getStructHash(typedData, 'EIP712Domain', typedData.domain).substring(2)).concat(getStructHash(typedData, typedData.primaryType, typedData.message).substring(2));\n  if (hash) {\n    return keccak256(message);\n  }\n  return message;\n};\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nconst encodeValue = (typedData, type, data) => {\n  const match = type.match(ARRAY_REGEX);\n  // Checks for array types\n  if (match) {\n    const arrayType = match[1];\n    const length = Number(match[2]) || undefined;\n    if (!Array.isArray(data)) {\n      throw new AbiError('Cannot encode data: value is not of array type', {\n        data\n      });\n    }\n    if (length && data.length !== length) {\n      throw new AbiError(\"Cannot encode data: expected length of \".concat(length, \", but got \").concat(data.length), {\n        data\n      });\n    }\n    const encodedData = data.map(item => encodeValue(typedData, arrayType, item));\n    const types = encodedData.map(item => item[0]);\n    const values = encodedData.map(item => item[1]);\n    return ['bytes32', keccak256(encodeParameters(types, values))];\n  }\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data)];\n  }\n  // Strings and arbitrary byte arrays are hashed to bytes32\n  if (type === 'string') {\n    return ['bytes32', keccak256(data)];\n  }\n  if (type === 'bytes') {\n    return ['bytes32', keccak256(data)];\n  }\n  return [type, data];\n};\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nconst encodeData = (typedData, type, data) => {\n  const [types, values] = typedData.types[type].reduce((_ref, field) => {\n    let [_types, _values] = _ref;\n    if (isNullish(data[field.name]) || isNullish(data[field.name])) {\n      throw new AbiError(\"Cannot encode data: missing data for '\".concat(field.name, \"'\"), {\n        data,\n        field\n      });\n    }\n    const value = data[field.name];\n    const [_type, encodedValue] = encodeValue(typedData, field.type, value);\n    return [[..._types, _type], [..._values, encodedValue]];\n  }, [['bytes32'], [getTypeHash(typedData, type)]]);\n  return encodeParameters(types, values);\n};","map":{"version":3,"names":["isNullish","keccak256","AbiError","encodeParameters","TYPE_REGEX","ARRAY_REGEX","getDependencies","typedData","type","dependencies","arguments","length","undefined","match","actualType","includes","types","reduce","previous","_type","filter","dependency","encodeType","primary","sort","map","concat","name","join","getTypeHash","getStructHash","data","encodeData","getMessage","hash","EIP_191_PREFIX","message","domain","substring","primaryType","encodeValue","arrayType","Number","Array","isArray","encodedData","item","values","_ref","field","_types","_values","value","encodedValue"],"sources":["C:\\Users\\SSAFY\\Desktop\\react\\S10P22C208\\frontend\\node_modules\\web3-eth-abi\\src\\eip_712.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * The web3.eth.abi functions let you encode and decode parameters to ABI (Application Binary Interface) for function calls to the EVM (Ethereum Virtual Machine).\n * \n *  For using Web3 ABI functions, first install Web3 package using `npm i web3` or `yarn add web3`.\n * After that, Web3 ABI functions will be available. \n * ```ts\n * import { Web3 } from 'web3';\n * \n * const web3 = new Web3();\n * const encoded = web3.eth.abi.encodeFunctionSignature({\n *     name: 'myMethod',\n *     type: 'function',\n *     inputs: [{\n *         type: 'uint256',\n *         name: 'myNumber'\n *     },{\n *         type: 'string',\n *         name: 'myString'\n *     }]\n * });\n * \n * ```\n * \n * For using individual package install `web3-eth-abi` package using `npm i web3-eth-abi` or `yarn add web3-eth-abi` and only import required functions.\n * This is more efficient approach for building lightweight applications. \n * ```ts\n * import { encodeFunctionSignature } from 'web3-eth-abi';\n * \n * const encoded = encodeFunctionSignature({\n *     name: 'myMethod',\n *     type: 'function',\n *     inputs: [{\n *         type: 'uint256',\n *         name: 'myNumber'\n *     },{\n *         type: 'string',\n *         name: 'myString'\n *     }]\n * });\n * \n * ```\n * \n *  @module ABI\n */\n\n\n// This code was taken from: https://github.com/Mrtenz/eip-712/tree/master\n\nimport { Eip712TypedData } from 'web3-types';\nimport { isNullish, keccak256 } from 'web3-utils';\nimport { AbiError } from 'web3-errors';\nimport { encodeParameters } from './coders/encode.js';\n\nconst TYPE_REGEX = /^\\w+/;\nconst ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nconst getDependencies = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdependencies: string[] = [],\n): string[] => {\n\tconst match = type.match(TYPE_REGEX)!;\n\tconst actualType = match[0];\n\tif (dependencies.includes(actualType)) {\n\t\treturn dependencies;\n\t}\n\n\tif (!typedData.types[actualType]) {\n\t\treturn dependencies;\n\t}\n\n\treturn [\n\t\tactualType,\n\t\t...typedData.types[actualType].reduce<string[]>(\n\t\t\t(previous, _type) => [\n\t\t\t\t...previous,\n\t\t\t\t...getDependencies(typedData, _type.type, previous).filter(\n\t\t\t\t\tdependency => !previous.includes(dependency),\n\t\t\t\t),\n\t\t\t],\n\t\t\t[],\n\t\t),\n\t];\n};\n\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nconst encodeType = (typedData: Eip712TypedData, type: string): string => {\n\tconst [primary, ...dependencies] = getDependencies(typedData, type);\n\t// eslint-disable-next-line @typescript-eslint/require-array-sort-compare\n\tconst types = [primary, ...dependencies.sort()];\n\n\treturn types\n\t\t.map(\n\t\t\tdependency =>\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t\t\t\t`${dependency}(${typedData.types[dependency].map(\n\t\t\t\t\t_type => `${_type.type} ${_type.name}`,\n\t\t\t\t)})`,\n\t\t)\n\t\t.join('');\n};\n\n/**\n * Get a type string as hash.\n */\nconst getTypeHash = (typedData: Eip712TypedData, type: string) =>\n\tkeccak256(encodeType(typedData, type));\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nconst getStructHash = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: Record<string, unknown>,\n\t// eslint-disable-next-line  no-use-before-define\n): string => keccak256(encodeData(typedData, type, data));\n\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nexport const getMessage = (typedData: Eip712TypedData, hash?: boolean): string => {\n\tconst EIP_191_PREFIX = '1901';\n\tconst message = `0x${EIP_191_PREFIX}${getStructHash(\n\t\ttypedData,\n\t\t'EIP712Domain',\n\t\ttypedData.domain as Record<string, unknown>,\n\t).substring(2)}${getStructHash(typedData, typedData.primaryType, typedData.message).substring(\n\t\t2,\n\t)}`;\n\n\tif (hash) {\n\t\treturn keccak256(message);\n\t}\n\n\treturn message;\n};\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nconst encodeValue = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: unknown,\n): [string, string | Uint8Array | number] => {\n\tconst match = type.match(ARRAY_REGEX);\n\n\t// Checks for array types\n\tif (match) {\n\t\tconst arrayType = match[1];\n\t\tconst length = Number(match[2]) || undefined;\n\n\t\tif (!Array.isArray(data)) {\n\t\t\tthrow new AbiError('Cannot encode data: value is not of array type', {\n\t\t\t\tdata,\n\t\t\t});\n\t\t}\n\n\t\tif (length && data.length !== length) {\n\t\t\tthrow new AbiError(\n\t\t\t\t`Cannot encode data: expected length of ${length}, but got ${data.length}`,\n\t\t\t\t{\n\t\t\t\t\tdata,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\tconst encodedData = data.map(item => encodeValue(typedData, arrayType, item));\n\t\tconst types = encodedData.map(item => item[0]);\n\t\tconst values = encodedData.map(item => item[1]);\n\n\t\treturn ['bytes32', keccak256(encodeParameters(types, values))];\n\t}\n\n\tif (typedData.types[type]) {\n\t\treturn ['bytes32', getStructHash(typedData, type, data as Record<string, unknown>)];\n\t}\n\n\t// Strings and arbitrary byte arrays are hashed to bytes32\n\tif (type === 'string') {\n\t\treturn ['bytes32', keccak256(data as string)];\n\t}\n\n\tif (type === 'bytes') {\n\t\treturn ['bytes32', keccak256(data as string)];\n\t}\n\n\treturn [type, data as string];\n};\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nconst encodeData = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: Record<string, unknown>,\n): string => {\n\tconst [types, values] = typedData.types[type].reduce<[string[], unknown[]]>(\n\t\t([_types, _values], field) => {\n\t\t\tif (isNullish(data[field.name]) || isNullish(data[field.name])) {\n\t\t\t\tthrow new AbiError(`Cannot encode data: missing data for '${field.name}'`, {\n\t\t\t\t\tdata,\n\t\t\t\t\tfield,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst value = data[field.name];\n\t\t\tconst [_type, encodedValue] = encodeValue(typedData, field.type, value);\n\n\t\t\treturn [\n\t\t\t\t[..._types, _type],\n\t\t\t\t[..._values, encodedValue],\n\t\t\t];\n\t\t},\n\t\t[['bytes32'], [getTypeHash(typedData, type)]],\n\t);\n\n\treturn encodeParameters(types, values);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}